generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              String              @id @default(uuid())
  phone           String              @unique
  name            String?
  email           String?
  password        String? // Mot de passe hash√© (optionnel pour OAuth)
  gender          String?
  role            String              @default("user")
  status          String              @default("pending")
  reputationScore Int                 @default(100)
  location        Json?
  birthDate       DateTime?
  notes           String?
  createdAt       DateTime            @default(now())
  updatedAt       DateTime?           @updatedAt
  alerts          Alert[]
  confirmations   AlertConfirmation[]
  notifications   Notification[]
  subscriptions   Subscription[]
  userInterests   UserInterest[] // Relation vers les int√©r√™ts de l'utilisateur
  images          Image[] // Images upload√©es par l'utilisateur
  uploadedImages  Image[]             @relation("UploadedImages") // Images upload√©es par cet admin/user
}

model Alert {
  id                     String              @id @default(uuid())
  userId                 String?
  category               String? // Deprecated - kept for migration, use categoryAlertId
  categoryAlertId        String? // Foreign key to CategoryAlert
  severity               String?
  description            String?
  location               Json?
  mediaUrl               String?
  expiresAt              DateTime?
  status                 String              @default("active")
  createdAt              DateTime            @default(now())
  title                  String
  displayTitle           String
  ref_alert_id           String
  source                 String?
  categorySpecificFields Json?
  user                   User?               @relation(fields: [userId], references: [id])
  categoryAlert          CategoryAlert?      @relation(fields: [categoryAlertId], references: [id])
  confirmedBy            AlertConfirmation[]
  notifications          Notification[]
  images                 Image[] // Images associ√©es √† cette alerte

  @@index([categoryAlertId])
}

model AlertConfirmation {
  id        Int      @id @default(autoincrement())
  userId    String
  alertId   String
  type      String
  createdAt DateTime @default(now())
  alert     Alert    @relation(fields: [alertId], references: [id])
  user      User     @relation(fields: [userId], references: [id])

  @@unique([userId, alertId])
}

model Subscription {
  id        Int      @id @default(autoincrement())
  userId    String
  type      String
  value     String
  createdAt DateTime @default(now())
  user      User     @relation(fields: [userId], references: [id])
}

model Notification {
  id      String   @id @default(uuid())
  userId  String
  alertId String?
  title   String
  content String
  wasSeen Boolean  @default(false)
  sentAt  DateTime @default(now())
  alert   Alert?   @relation(fields: [alertId], references: [id])
  user    User     @relation(fields: [userId], references: [id])
}

model MessageBot {
  id                  Int      @id @default(autoincrement())
  platform            String
  senderPhone         String
  rawMessage          String
  interpretedCategory String?
  interpretedLocation String?
  interpretedSeverity String?
  alertCreated        Boolean  @default(false)
  createdAt           DateTime @default(now())
}

model MonitoredSource {
  id             String    @id @default(uuid())
  name           String
  url            String
  sourceType     String    @default("social") // 'social' | 'website' | 'rss' | 'api'
  platform       String // 'whatsapp' | 'telegram' | 'facebook' | 'website' | 'rss-feed'
  scrapingConfig Json? // Configuration flexible pour chaque type
  isActive       Boolean   @default(true)
  lastScraped    DateTime?
  contentCount   Int       @default(0)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  @@index([sourceType, isActive])
  @@map("social_links") // Garder le nom de table pour √©viter migration complexe
}

model BroadcastChannel {
  id             String         @id @default(uuid())
  name           String // Ex: "Canal WhatsApp JAPAP", "JAPAP Telegram Official"
  platform       String // 'whatsapp' | 'telegram' | 'instagram'
  credentials    Json // Token, Channel ID, Username selon plateforme
  isActive       Boolean        @default(true)
  followerCount  Int? // Nombre d'abonn√©s (optionnel)
  lastBroadcast  DateTime? // Date derni√®re diffusion
  broadcastCount Int            @default(0)
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  broadcasts     BroadcastLog[]

  @@index([platform, isActive])
}

model BroadcastLog {
  id        String           @id @default(uuid())
  channelId String
  alertId   String
  status    String           @default("pending") // 'pending' | 'sent' | 'failed'
  message   String? // Message format√© envoy√©
  response  Json? // R√©ponse de l'API (ID message, erreurs, etc.)
  sentAt    DateTime         @default(now())
  channel   BroadcastChannel @relation(fields: [channelId], references: [id])

  @@index([alertId, status])
  @@index([channelId, sentAt])
}

model Interest {
  id                     String                  @id @default(uuid())
  label                  String                  @unique // "Alertes de s√©curit√© √† proximit√©"
  code                   String                  @unique // "nearby_alerts"
  description            String?
  createdAt              DateTime                @default(now())
  userInterests          UserInterest[]
  categoryAlertInterests CategoryAlertInterest[]
}

model UserInterest {
  id         String   @id @default(uuid())
  userId     String
  interestId String
  createdAt  DateTime @default(now())

  user     User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  interest Interest @relation(fields: [interestId], references: [id], onDelete: Cascade)

  @@unique([userId, interestId])
  @@index([userId])
  @@index([interestId])
}

// ============ CATEGORY ALERT MODELS ============

model CategoryAlert {
  id          String  @id @default(uuid())
  code        String  @unique // "MEDC", "FIRV", "ACCG", etc.
  name        String // "Urgence m√©dicale critique"
  description String?

  // M√©tadonn√©es visuelles
  icon  String // "üöë", "üî•", "üöó"
  color String // "#dc2626"

  // Classification
  priority        String // "critical", "high", "medium", "low"
  defaultSeverity String @default("medium") // "critical", "high", "medium", "low"

  // Temps de r√©ponse et expiration
  responseTime    Int // minutes (5, 15, 30, 60)
  expirationHours Int? // Heures avant d√©priorisation (null = jamais, ex: disparitions)

  // Services d'urgence et routage (JSON arrays)
  emergencyServices Json // ["SAMU", "Police", "Pompiers"]
  routingMatrix     Json // ["Police", "Gendarmerie", "SAMU"]

  // Parsing NLP (keywords pour d√©tection dans messages)
  keywords Json // ["urgent", "accident", "bless√©"]

  // √âtat et ordre
  isActive Boolean @default(true)
  order    Int     @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  alerts                 Alert[]
  categoryAlertInterests CategoryAlertInterest[]

  @@index([code])
  @@index([priority, isActive])
  @@index([order])
}

// Table de liaison entre Interest (pr√©f√©rences user) et CategoryAlert (types alertes)
model CategoryAlertInterest {
  id              String   @id @default(uuid())
  interestId      String
  categoryAlertId String
  priority        Int      @default(0) // Ordre de priorit√© pour l'utilisateur
  createdAt       DateTime @default(now())

  interest      Interest      @relation(fields: [interestId], references: [id], onDelete: Cascade)
  categoryAlert CategoryAlert @relation(fields: [categoryAlertId], references: [id], onDelete: Cascade)

  @@unique([interestId, categoryAlertId])
  @@index([interestId])
  @@index([categoryAlertId])
}

// ============ IMAGE MANAGEMENT MODELS ============

model Image {
  id           String   @id @default(uuid())
  filename     String // Nom du fichier stock√© (avec timestamp)
  originalName String // Nom original du fichier upload√©
  path         String // Chemin relatif: /uploads/alerts/123/image.jpg
  url          String // URL compl√®te accessible
  size         Int // Taille en bytes
  mimeType     String // image/jpeg, image/png, etc.
  width        Int? // Largeur de l'image en pixels
  height       Int? // Hauteur de l'image en pixels

  // Relations
  alertId String? // Alerte associ√©e (optionnel)
  alert   Alert?  @relation(fields: [alertId], references: [id], onDelete: Cascade)

  userId String? // Propri√©taire de l'image
  user   User?   @relation(fields: [userId], references: [id], onDelete: Cascade)

  uploadedBy String? // Qui a upload√© (admin/user)
  uploader   User?   @relation("UploadedImages", fields: [uploadedBy], references: [id], onDelete: SetNull)

  // Cat√©gorisation
  category String? // "alert", "user", "admin", "broadcast", "temp"
  isPublic Boolean @default(false) // Accessible publiquement ou priv√©

  // M√©tadonn√©es
  metadata Json? // { thumbnail: "/path/to/thumb.jpg", watermark: true, compressed: true, ... }

  // Stockage
  storage String @default("local") // "local" ou "remote"

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([alertId])
  @@index([userId])
  @@index([category])
  @@index([createdAt])
}
